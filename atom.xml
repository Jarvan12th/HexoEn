<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>All About Jarvan</title>
  
  <subtitle>Jarvan</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-12-06T14:30:39.673Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Jarvan Lee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode-daily-practice-20211206</title>
    <link href="http://example.com/2021/12/06/Leetcode-daily-practice-20211206/"/>
    <id>http://example.com/2021/12/06/Leetcode-daily-practice-20211206/</id>
    <published>2021-12-06T14:05:33.000Z</published>
    <updated>2021-12-06T14:30:39.673Z</updated>
    
    <content type="html"><![CDATA[<h5 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></h5><p>我首先从左上角出发，考虑右侧和下方的数字，如果小于target就推入队列，循环出列，直到找到target，或者没有找到target返回false。其中还用了m*n大小的布尔数组，来标记某数字是否检查过。但其实有更好的思路：从数组的右上角看是二分查找，元素小于target向下找，元素大于target向左找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(matrix[x][y] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&lt;m &amp;&amp; y&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[x][y] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(matrix[x][y] &gt; target)&#123;</span><br><span class="line">                y --;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(matrix[x][y] &lt; target)&#123;</span><br><span class="line">                x ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(m+n)</li><li>空间复杂度：O(1)</li></ul><h5 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a></h5><p>关于树的算法一般来说有递归和迭代两种方法。递归思路清晰，但需要使用递归栈；迭代需要使用栈或队列。</p><ol><li><p>递归</p><p>首先使用map存储中序遍历，key为元素，value为index，这样方便查询父节点的位置。</p><p>前序遍历的形式为<code>[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]</code></p><p>中序遍历的形式为<code>[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]</code></p><p>从前序遍历得到父节点的值，根据值在map中找到父节点的下标，据此下标计算左子树的节点个数，右子树的节点个数。然后递归建立左右子树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; all_treenode_map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = inorder.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) all_treenode_map.put(inorder[i], i);</span><br><span class="line">        <span class="keyword">return</span> buildMyTree(preorder, inorder, <span class="number">0</span>, n-<span class="number">1</span>, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildMyTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> pre_left, <span class="keyword">int</span> pre_right, <span class="keyword">int</span> in_left, <span class="keyword">int</span> in_right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre_left &gt; pre_right) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> root_value = preorder[pre_left];</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(root_value);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> root_index_in_inorder = all_treenode_map.get(root_value);</span><br><span class="line">        <span class="keyword">int</span> left_length = root_index_in_inorder - in_left;</span><br><span class="line">        root.left = buildMyTree(preorder, inorder, pre_left+<span class="number">1</span>, pre_left+left_length, in_left, root_index_in_inorder-<span class="number">1</span>);</span><br><span class="line">        root.right = buildMyTree(preorder, inorder, pre_left+left_length+<span class="number">1</span>, pre_right, root_index_in_inorder+<span class="number">1</span>, in_right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul></li><li><p>迭代不容易理解，这里借鉴了官方题解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder == <span class="keyword">null</span> || preorder.length ==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">int</span> in_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;preorder.length; i++)&#123;</span><br><span class="line">            <span class="comment">// 前序遍历中父节点的下一位（左子树不为空，是左子树的val，左子树为空，是右子树的val）</span></span><br><span class="line">            <span class="keyword">int</span> pre_val = preorder[i];</span><br><span class="line">            TreeNode node = stack.peek();</span><br><span class="line">            <span class="comment">// 中序遍历时没到父节点时，都是左子树的节点</span></span><br><span class="line">            <span class="keyword">if</span>(node.val != inorder[in_index])&#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> TreeNode(pre_val);</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            <span class="comment">// 中序遍历到了父节点，这时候建右子树</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 找到父节点</span></span><br><span class="line">                <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek().val == inorder[in_index])&#123;</span><br><span class="line">                    <span class="comment">// 倒出父节点（已经建好了左子树）</span></span><br><span class="line">                    node = stack.pop();</span><br><span class="line">                    in_index ++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 建立右子树</span></span><br><span class="line">                node.right = <span class="keyword">new</span> TreeNode(pre_val);</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：O(n)</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;剑指-Offer-04-二维数组中的查找&quot;&gt;&lt;a href=&quot;#剑指-Offer-04-二维数组中的查找&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 04. 二维数组中的查找&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-weekly-contest-270</title>
    <link href="http://example.com/2021/12/05/Leetcode-weekly-contest-270/"/>
    <id>http://example.com/2021/12/05/Leetcode-weekly-contest-270/</id>
    <published>2021-12-05T10:05:57.000Z</published>
    <updated>2021-12-05T14:33:15.832Z</updated>
    
    <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th>Score</th><th>Finish Time</th><th>Q1(3)</th><th>Q2(4)</th><th>Q3(5)</th><th>Q4(6)</th></tr></thead><tbody><tr><td>4</td><td>Null</td><td>Null</td><td>0:19:33</td><td>30:00</td><td>Null</td></tr></tbody></table></div><p>这周的题目特别不对味儿，可能这就是真实的周赛，也可能我只是周赛新手。</p><h5 id="5942-简单-找出-3-位偶数"><a href="#5942-简单-找出-3-位偶数" class="headerlink" title="5942(简单)找出 3 位偶数"></a>5942(简单)<a href="https://leetcode-cn.com/problems/finding-3-digit-even-numbers/">找出 3 位偶数</a></h5><p>这题找出3位偶数有三个规则，而且还要满足<code>全部</code>和<code>互不相同</code>，最后按照<code>递增顺序</code>返回，很容易造成思路的混乱，最简单的方法是排除不满足规则的数，最后去重，排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findEvenNumbers(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = digits.length;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i != j &amp;&amp; j != k &amp;&amp; i != k &amp;&amp; digits[i] != <span class="number">0</span> &amp;&amp; digits[k]%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                        set.add(digits[i]*<span class="number">100</span> + digits[j]*<span class="number">10</span> + digits[k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[set.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> temp : set)&#123;</span><br><span class="line">            result[index++] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK7之后，Array.sort()采用Timesrot排序算法，最坏时间复杂度为O(n*logn)，最坏空间复杂度是O(n/2)</p><ul><li>时间复杂度O(N^3)</li><li>空间复杂度（最坏O(n/2)）</li></ul><h5 id="5943-中等-删除链表的中间节点"><a href="#5943-中等-删除链表的中间节点" class="headerlink" title="5943(中等)删除链表的中间节点"></a>5943(中等)<a href="https://leetcode-cn.com/problems/delete-the-middle-node-of-a-linked-list/">删除链表的中间节点</a></h5><p>这是典型的快慢指针题目。唯一要注意的是，中间节点是⌊n/2⌋（<code>⌊x⌋</code>表示≤x的最大整数），这会导致快指针到最后位置时，慢指针正好是要删除的节点，所以要记录慢指针的前节点，方便删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteMiddle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        ListNode pre = slow;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre.next = slow.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(1)</li></ul><h5 id="5944-中等-从二叉树一个节点到另一个节点每一步的方向"><a href="#5944-中等-从二叉树一个节点到另一个节点每一步的方向" class="headerlink" title="5944(中等)从二叉树一个节点到另一个节点每一步的方向"></a>5944(中等)<a href="https://leetcode-cn.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/">从二叉树一个节点到另一个节点每一步的方向</a></h5><p>首先是寻找两个节点的最小公共祖先，参考<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree">LC.236(中等)二叉树的最近公共祖先</a>，然后求youngest_root到dest的路径，youngest_root到start的深度，这代表U的数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;    </span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDirections</span><span class="params">(TreeNode root, <span class="keyword">int</span> startValue, <span class="keyword">int</span> destValue)</span> </span>&#123;</span><br><span class="line">        TreeNode young_root = dfs(root, startValue, destValue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加start到young_root的路径</span></span><br><span class="line">        <span class="keyword">int</span> num = findStart(young_root, startValue);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">            res.append(<span class="string">&#x27;U&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加root到young_root的路径</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        findDest(young_root, destValue, sb);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//寻找最近的公共祖先young_root</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> startValue, <span class="keyword">int</span> destValue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root.val == startValue || root.val == destValue)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode l = dfs(root.left, startValue, destValue);</span><br><span class="line">        TreeNode r = dfs(root.right, startValue, destValue);</span><br><span class="line">        <span class="keyword">if</span>(l != <span class="keyword">null</span> &amp;&amp; r != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻找start到young_root有几个U</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findStart</span><span class="params">(TreeNode root, <span class="keyword">int</span> srcValue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val == srcValue)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(findStart(root.left, srcValue), findStart(root.right, srcValue)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻找young_root到dest的路径</span></span><br><span class="line">    <span class="comment">//sb.deleteCharAt()表示，如果没有找到左子树或右子树没有找到dest，就删除刚刚添加的&#x27;L&#x27;或&#x27;R&#x27;，还原路径。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findDest</span><span class="params">(TreeNode root, <span class="keyword">int</span> destValue, StringBuilder sb)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.val == destValue)&#123;</span><br><span class="line">            res.append(sb.toString());</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            sb.append(<span class="string">&#x27;R&#x27;</span>);</span><br><span class="line">            findDest(root.right, destValue, sb);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            sb.append(<span class="string">&#x27;L&#x27;</span>);</span><br><span class="line">            findDest(root.left, destValue, sb);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>空间复杂度：递归栈至多O(n)</li></ul><h5 id="5932-困难-合法重新排列数对"><a href="#5932-困难-合法重新排列数对" class="headerlink" title="5932(困难)合法重新排列数对"></a>5932(困难)<a href="https://leetcode-cn.com/problems/valid-arrangement-of-pairs/">合法重新排列数对</a></h5><p>找到一个<code>出度（从该点出发的边的数量）</code>比 <code>入度（进入该点的边的数量）</code>大1的点作为起点。如果没找到这样的一个点，那么任何一个点都可以作为起点，这时所有点的<code>入度 = 出度</code>。做法是，从起点出发，遍历任意边，然后把边删除。如果当前点没有任何边连出，才在结果中加入该点（排除环）。递归进行这个过程，得到 “一笔画” 路径的 逆序。最后把路径翻转即可得到最终结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//存放最后遍历的顺序</span></span><br><span class="line">    LinkedList&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//存放所有元素的入度元素</span></span><br><span class="line">    Map&lt;Integer, LinkedList&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//存放所有元素的入度</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; inDegree = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] validArrangement(<span class="keyword">int</span>[][] pairs) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] pair : pairs)&#123;</span><br><span class="line">            <span class="keyword">int</span> out = pair[<span class="number">0</span>], in = pair[<span class="number">1</span>];</span><br><span class="line">            inDegree.put(in, inDegree.getOrDefault(in, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            LinkedList&lt;Integer&gt; list = map.getOrDefault(out, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">            list.add(in);</span><br><span class="line">            map.put(out, list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = pairs[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, LinkedList&lt;Integer&gt;&gt; entry : map.entrySet())&#123;</span><br><span class="line">            <span class="keyword">int</span> key = entry.getKey();</span><br><span class="line">            LinkedList&lt;Integer&gt; outList = entry.getValue();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> inValue = inDegree.getOrDefault(key, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(inValue + <span class="number">1</span> == outList.size())&#123;</span><br><span class="line">                start = key;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(start);</span><br><span class="line">        <span class="keyword">int</span> n = pairs.length;</span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            ans[i][<span class="number">0</span>] = result.pollLast();</span><br><span class="line">            ans[i][<span class="number">1</span>] = result.peekLast();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; list = map.get(start);</span><br><span class="line">        <span class="keyword">while</span>(list != <span class="keyword">null</span> &amp;&amp; !list.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> next = list.pollLast();</span><br><span class="line">            dfs(next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result.add(start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间复杂度：O(pairs.length)</p></li><li><p>空间复杂度：O(pairs.length)</p><p>注意题目中排除了自循环和重复循环的用例，否则这个算法不可行。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Score&lt;/th&gt;
&lt;th&gt;Finish Time&lt;/th&gt;
&lt;th&gt;Q1(3)&lt;/th&gt;
&lt;th&gt;Q2(4)&lt;/th&gt;
&lt;th&gt;Q3(5)&lt;/th&gt;
&lt;th&gt;Q4(6</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-weekly-contest-269</title>
    <link href="http://example.com/2021/11/29/Leetcode-weekly-contest-269/"/>
    <id>http://example.com/2021/11/29/Leetcode-weekly-contest-269/</id>
    <published>2021-11-29T02:41:05.000Z</published>
    <updated>2021-11-29T03:28:37.942Z</updated>
    
    <content type="html"><![CDATA[<div class="table-container"><table><thead><tr><th>Score</th><th>Finish Time</th><th>Q1(3)</th><th>Q2(4)</th><th>Q3(5)</th><th>Q4(6)</th></tr></thead><tbody><tr><td>8</td><td>Null</td><td>5:00</td><td>Null</td><td>30:00</td><td>Null</td></tr></tbody></table></div><h5 id="5938-简单-找出数组排序后的目标下表"><a href="#5938-简单-找出数组排序后的目标下表" class="headerlink" title="5938(简单) 找出数组排序后的目标下表"></a>5938(简单) 找出数组排序后的目标下表</h5><p>​    <a href="https://leetcode-cn.com/problems/find-target-indices-after-sorting-array/">https://leetcode-cn.com/problems/find-target-indices-after-sorting-array/</a></p><h5 id="5939-中等-半径为-k-的子数组平均值"><a href="#5939-中等-半径为-k-的子数组平均值" class="headerlink" title="5939(中等) 半径为 k 的子数组平均值"></a>5939(中等) 半径为 k 的子数组平均值</h5><p>​    <a href="https://leetcode-cn.com/problems/k-radius-subarray-averages/">https://leetcode-cn.com/problems/k-radius-subarray-averages/</a></p><p>​    这题我的思路不错，下标自增的时候，k半径范围内的数一增一减。但实际上花了很多时间，主要是写了很多if分支，在确定每个分支的功能时花了很多时间。最后还吃了三次罚时，第一次是因为忘记删除debug信息，第二次未通过但没看错误信息，第三次想不到错误的点故意吃的罚时。未通过的用例k为40000，范围很大，就没有再调试了，最后评论区找到了更好的思路。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getAverages(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">        Arrays.fill(res,-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">2</span>*k)&#123;</span><br><span class="line">                res[i - k] = (<span class="keyword">int</span>)(sum / (<span class="number">2</span> * k + <span class="number">1</span>));</span><br><span class="line">                sum -= nums[i - <span class="number">2</span>*k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2091-中等-从数组中移除最大值和最小值"><a href="#2091-中等-从数组中移除最大值和最小值" class="headerlink" title="2091(中等) 从数组中移除最大值和最小值"></a>2091(中等) 从数组中移除最大值和最小值</h5><p>​    <a href="https://leetcode-cn.com/problems/removing-minimum-and-maximum-from-array/">https://leetcode-cn.com/problems/removing-minimum-and-maximum-from-array/</a></p><h5 id="5941-困难-找出知晓秘密的所有专家"><a href="#5941-困难-找出知晓秘密的所有专家" class="headerlink" title="5941(困难) 找出知晓秘密的所有专家"></a>5941(困难) 找出知晓秘密的所有专家</h5><p>​    <a href="https://leetcode-cn.com/problems/find-all-people-with-secret/">https://leetcode-cn.com/problems/find-all-people-with-secret/</a></p><p>这题考察图的遍历</p><p>Dijkstra算法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAllPeople</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] meetings, <span class="keyword">int</span> firstPerson)</span> </span>&#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt;[] graph = <span class="keyword">new</span> ArrayList[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] meeting : meetings) &#123;</span><br><span class="line">            graph[meeting[<span class="number">0</span>]].add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;meeting[<span class="number">1</span>], meeting[<span class="number">2</span>]&#125;);</span><br><span class="line">            graph[meeting[<span class="number">1</span>]].add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;meeting[<span class="number">0</span>], meeting[<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 按时间排序</span></span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; q = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; (o1[<span class="number">1</span>] - o2[<span class="number">1</span>]));</span><br><span class="line">        q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;); q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;firstPerson, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">boolean</span>[] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = q.poll();</span><br><span class="line">            <span class="keyword">int</span> v = cur[<span class="number">0</span>], t = cur[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            vis[v] = <span class="keyword">true</span>;</span><br><span class="line">            res.add(v);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] next : graph[cur[<span class="number">0</span>]]) &#123;</span><br><span class="line">                <span class="keyword">int</span> p = next[<span class="number">0</span>], time = next[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (vis[p] || time &lt; t) <span class="keyword">continue</span>;</span><br><span class="line">                q.offer(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>排序+查并集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 并查集数组，记录每个元素的祖先节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] p;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找每个元素的祖先，（路径压缩，并查集模板）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x] != x) p[x] = find(p[x]);</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAllPeople</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] meetings, <span class="keyword">int</span> firstPerson)</span> </span>&#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 祖先数组初始化，将每个元素的祖先标记为自己</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) p[i] = i;</span><br><span class="line">        <span class="comment">// 合并0号专家与firstPerson</span></span><br><span class="line">        p[firstPerson] = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, List&lt;<span class="keyword">int</span>[]&gt;&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 构造以时刻为key，会议列表为value的Map，TreeMap将自动按照key升序排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] m : meetings) &#123;</span><br><span class="line">            <span class="comment">// m[2]为会议时刻，每个时刻对应多场会议</span></span><br><span class="line">            List&lt;<span class="keyword">int</span>[]&gt; list = map.getOrDefault(m[<span class="number">2</span>], <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            list.add(m);</span><br><span class="line">            map.put(m[<span class="number">2</span>], list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于每个时刻，遍历两次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : map.keySet()) &#123;</span><br><span class="line">            <span class="comment">// 第一轮遍历，合并集合</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] l : map.get(x)) &#123;</span><br><span class="line">                <span class="keyword">int</span> a = l[<span class="number">0</span>], b = l[<span class="number">1</span>];                </span><br><span class="line">                <span class="keyword">if</span> (p[find(a)] == <span class="number">0</span> || p[find(b)] == <span class="number">0</span>) &#123; p[find(a)] = <span class="number">0</span>; p[find(b)] = <span class="number">0</span>; &#125;</span><br><span class="line">                p[find(b)] = p[find(a)];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第二轮遍历，分场景讨论</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] l : map.get(x)) &#123;</span><br><span class="line">                <span class="keyword">int</span> a = l[<span class="number">0</span>], b = l[<span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 场景一：两位专家在前面的会议均不知道秘密，后面遍历中其中一位专家知道了秘密，瞬时共享，两人都将知道秘密</span></span><br><span class="line">                <span class="keyword">if</span> (p[find(a)] == <span class="number">0</span> || p[find(b)] == <span class="number">0</span>) &#123; p[find(a)] = <span class="number">0</span>; p[find(b)] = <span class="number">0</span>; &#125;</span><br><span class="line">                <span class="comment">// 场景二：两位专家在该时刻始终都不知道秘密，将合并的集合分离开，防止后面时刻有一个专家知道秘密，将秘密分享给另一个专家</span></span><br><span class="line">                <span class="keyword">else</span> &#123; p[a] = a; p[b] = b; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 祖先为0的元素即为知道秘密的专家</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[find(i)] == <span class="number">0</span>) ans.add(i);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Score&lt;/th&gt;
&lt;th&gt;Finish Time&lt;/th&gt;
&lt;th&gt;Q1(3)&lt;/th&gt;
&lt;th&gt;Q2(4)&lt;/th&gt;
&lt;th&gt;Q3(5)&lt;/th&gt;
&lt;th&gt;Q4(6</summary>
      
    
    
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>阿里云部署SpringBoot应用</title>
    <link href="http://example.com/2021/11/29/%E9%98%BF%E9%87%8C%E4%BA%91%E9%83%A8%E7%BD%B2SpringBoot%E5%BA%94%E7%94%A8/"/>
    <id>http://example.com/2021/11/29/%E9%98%BF%E9%87%8C%E4%BA%91%E9%83%A8%E7%BD%B2SpringBoot%E5%BA%94%E7%94%A8/</id>
    <published>2021-11-29T00:54:11.000Z</published>
    <updated>2021-11-29T02:32:54.248Z</updated>
    
    <content type="html"><![CDATA[<p>我买了阿里云的轻量服务器，双十一的折扣不要太划算，43块钱租赁一整年。服务器系统设置成CentOS8，用来验证Spring Boot应用的部署环节。</p><p>部署的流程很简单：本地成功运行SpringBoot应用 -&gt; 打成jar包 -&gt; 配置CentOS环境 -&gt; 部署jar包到服务器，可实际上，过程中走了很多弯路，却也有趣。从下午6点一直到1点半，我十分投入，甚至晚饭也忘了。本来打算立即写下这件事的，迫于太晚了，只好推到了早上。</p><p>  本地运行SpringBoot</p><p>这个应用克隆自<code>https://github.com/gabrieldim/Email-Sender-Spring-Boot.git</code>，实现了通过url发送邮件。需要配置发送人的邮箱信息，这里我用了QQ邮箱做测试。</p><p>注意要开启邮箱的第三方服务</p><img src="/2021/11/29/%E9%98%BF%E9%87%8C%E4%BA%91%E9%83%A8%E7%BD%B2SpringBoot%E5%BA%94%E7%94%A8/qq_mail_third_party_service_enable.png" class title="开启QQ邮箱第三方服务"><p>  打成jar包</p><p>这里我使用了IDEA的打包工具，但是IDEA给我留了陷阱。</p><img src="/2021/11/29/%E9%98%BF%E9%87%8C%E4%BA%91%E9%83%A8%E7%BD%B2SpringBoot%E5%BA%94%E7%94%A8/idea-build_detail_info.png" class title="IDEA打jar包细节信息"><p>这里的MANIFEST.MF文件应该放在根目录下，也即删除<code>\src\main\java</code>，然后顺着流程走下来，jar包放在<code>.out\artifacts\email_sender-jar</code></p><p>  配置CentOS</p><p>主要有两部分，安装jdk11和Tomcat。</p><p>安装jdk11走了很多弯路，最开始我用wget安装，但是在Oracle官网下载的tar.gz文件总是HTML类型的，导致解压出错。即使在wget命令中添加同意协议的cookie信息，依然如此。最后我换了思路，我先下载到windows本地，然后上传到LINUX服务器。</p><p>上传的操作利用了PPUTY工具。其实有很多方法的，但是之前连接AWS虚机的时候安装了PUTTY，所以直接拿来用最方便啦。PPUTY的命令是<code>pscp 本机压缩文件 Linux用户@Linux公用IP:Linux服务器目录</code>。</p><p>JDK安装包上传到服务器，首先用<code>tar -zxvf jdk-11.0.13-linux-x64.tar.gz</code>解压到<code>/usr/local/java</code>，这是我放置安装包的地方。然后在<code>vim /etc/profile</code>配置环境变量，在文件末尾添加``</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">## JAVA</span><br><span class="line">JAVA_HOME=/usr/local/jdk-<span class="number">11.0</span>.<span class="number">13</span></span><br><span class="line">JRE_HOME=/usr/local/jdk-<span class="number">11.0</span>.<span class="number">13</span></span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</span><br><span class="line">CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib</span><br><span class="line">export JAVA_HOME JRE_HOME PATH CLASSPATH</span><br></pre></td></tr></table></figure><p>最后要<code>source /etc/profile</code>刷新当前shell环境。<code>java -version</code>看到Java信息就算成功。</p><p>安装Tomcat最艰难，下载和安装过程和jdk大同小异，只是安装目录是<code>/usr/local/tomcat/apache-tomcat-10.0.13</code>，执行bin目录下启动命令<code>./startup.sh</code>，但是tomcat的启动日志<code>tail -f ../logs/catalina.out</code>一直报错，无法找到<code>./jdk-11.0.13/bin/jre/bin/java</code>无法找到路径，cd到相应目录发现没有jre目录，原来是Oracle搞得鬼，JDK11及以后，不单独提供JRE模块，但是用户可以自行创建JRE，命令则是在jdk的bin目录下执行<code>jlink.exe --module-path jmods --add-modules java.desktop --output jre</code>。之后重启Tomcat还是有错误，把JRE配置为和JDK同一目录便解决啦。</p><p>这时Tomcat已经安装好啦。我用windows的浏览器试着连接服务器的8080端口，但一直超时。这部分查了很久，直到看到有篇文章无心插柳提到了防火墙，我想起我忘了开放服务器的8080端口了Orz。</p><p>  部署应用</p><p>第一次没有成功，解决了上文IDEA留的陷阱就可以啦。</p><p>jar包目录下执行<code>java -jar email-sender.jar</code>可以看到Spring的信息。成功！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我买了阿里云的轻量服务器，双十一的折扣不要太划算，43块钱租赁一整年。服务器系统设置成CentOS8，用来验证Spring Boot应用的部署环节。&lt;/p&gt;
&lt;p&gt;部署的流程很简单：本地成功运行SpringBoot应用 -&amp;gt; 打成jar包 -&amp;gt; 配置CentOS</summary>
      
    
    
    
    
    <category term="aliyun" scheme="http://example.com/tags/aliyun/"/>
    
    <category term="springboot" scheme="http://example.com/tags/springboot/"/>
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
    <category term="deploy" scheme="http://example.com/tags/deploy/"/>
    
  </entry>
  
  <entry>
    <title>PTE-Score</title>
    <link href="http://example.com/2021/11/27/PTE-Score/"/>
    <id>http://example.com/2021/11/27/PTE-Score/</id>
    <published>2021-11-27T01:45:19.000Z</published>
    <updated>2021-11-27T01:49:07.924Z</updated>
    
    <content type="html"><![CDATA[<p>2021.09.18</p><img src="/2021/11/27/PTE-Score/pte-score.png" class title="This is the newest pte score">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2021.09.18&lt;/p&gt;
&lt;img src=&quot;/2021/11/27/PTE-Score/pte-score.png&quot; class title=&quot;This is the newest pte score&quot;&gt;
</summary>
      
    
    
    
    <category term="certification" scheme="http://example.com/categories/certification/"/>
    
    
    <category term="certification" scheme="http://example.com/tags/certification/"/>
    
    <category term="pte" scheme="http://example.com/tags/pte/"/>
    
  </entry>
  
  <entry>
    <title>AWS SAP Certification</title>
    <link href="http://example.com/2021/06/28/AWS-SAP-Certification/"/>
    <id>http://example.com/2021/06/28/AWS-SAP-Certification/</id>
    <published>2021-06-28T14:46:00.000Z</published>
    <updated>2021-06-28T15:08:13.087Z</updated>
    
    <content type="html"><![CDATA[<p>2021.06.24</p><img src="/2021/06/28/AWS-SAP-Certification/aws-sap-certification.png" class title="This is aws sap certification">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2021.06.24&lt;/p&gt;
&lt;img src=&quot;/2021/06/28/AWS-SAP-Certification/aws-sap-certification.png&quot; class title=&quot;This is aws sap certification&quot;&gt;</summary>
      
    
    
    
    <category term="certification" scheme="http://example.com/categories/certification/"/>
    
    
    <category term="aws" scheme="http://example.com/tags/aws/"/>
    
    <category term="certification" scheme="http://example.com/tags/certification/"/>
    
  </entry>
  
</feed>
