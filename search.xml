<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AWS SAP Certification</title>
    <url>/2021/06/28/AWS-SAP-Certification/</url>
    <content><![CDATA[<p>2021.06.24</p>
<img src="/2021/06/28/AWS-SAP-Certification/aws-sap-certification.png" class title="This is aws sap certification">]]></content>
      <categories>
        <category>certification</category>
      </categories>
      <tags>
        <tag>aws</tag>
        <tag>certification</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-daily-practice-20211206</title>
    <url>/2021/12/06/Leetcode-daily-practice-20211206/</url>
    <content><![CDATA[<h5 id="剑指-Offer-04-二维数组中的查找"><a href="#剑指-Offer-04-二维数组中的查找" class="headerlink" title="剑指 Offer 04. 二维数组中的查找"></a><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></h5><p>我首先从左上角出发，考虑右侧和下方的数字，如果小于target就推入队列，循环出列，直到找到target，或者没有找到target返回false。其中还用了m*n大小的布尔数组，来标记某数字是否检查过。但其实有更好的思路：从数组的右上角看是二分查找，元素小于target向下找，元素大于target向左找。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(matrix[x][y] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(x&lt;m &amp;&amp; y&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[x][y] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(matrix[x][y] &gt; target)&#123;</span><br><span class="line">                y --;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(matrix[x][y] &lt; target)&#123;</span><br><span class="line">                x ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(m+n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h5 id="剑指-Offer-07-重建二叉树"><a href="#剑指-Offer-07-重建二叉树" class="headerlink" title="剑指 Offer 07. 重建二叉树"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a></h5><p>关于树的算法一般来说有递归和迭代两种方法。递归思路清晰，但需要使用递归栈；迭代需要使用栈或队列。</p>
<ol>
<li><p>递归</p>
<p>首先使用map存储中序遍历，key为元素，value为index，这样方便查询父节点的位置。</p>
<p>前序遍历的形式为<code>[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]</code></p>
<p>中序遍历的形式为<code>[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]</code></p>
<p>从前序遍历得到父节点的值，根据值在map中找到父节点的下标，据此下标计算左子树的节点个数，右子树的节点个数。然后递归建立左右子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; all_treenode_map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = inorder.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) all_treenode_map.put(inorder[i], i);</span><br><span class="line">        <span class="keyword">return</span> buildMyTree(preorder, inorder, <span class="number">0</span>, n-<span class="number">1</span>, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildMyTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> pre_left, <span class="keyword">int</span> pre_right, <span class="keyword">int</span> in_left, <span class="keyword">int</span> in_right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre_left &gt; pre_right) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> root_value = preorder[pre_left];</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(root_value);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> root_index_in_inorder = all_treenode_map.get(root_value);</span><br><span class="line">        <span class="keyword">int</span> left_length = root_index_in_inorder - in_left;</span><br><span class="line">        root.left = buildMyTree(preorder, inorder, pre_left+<span class="number">1</span>, pre_left+left_length, in_left, root_index_in_inorder-<span class="number">1</span>);</span><br><span class="line">        root.right = buildMyTree(preorder, inorder, pre_left+left_length+<span class="number">1</span>, pre_right, root_index_in_inorder+<span class="number">1</span>, in_right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
</li>
<li><p>迭代不容易理解，这里借鉴了官方题解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder == <span class="keyword">null</span> || preorder.length ==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">int</span> in_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;preorder.length; i++)&#123;</span><br><span class="line">            <span class="comment">// 前序遍历中父节点的下一位（左子树不为空，是左子树的val，左子树为空，是右子树的val）</span></span><br><span class="line">            <span class="keyword">int</span> pre_val = preorder[i];</span><br><span class="line">            TreeNode node = stack.peek();</span><br><span class="line">            <span class="comment">// 中序遍历时没到父节点时，都是左子树的节点</span></span><br><span class="line">            <span class="keyword">if</span>(node.val != inorder[in_index])&#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> TreeNode(pre_val);</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            <span class="comment">// 中序遍历到了父节点，这时候建右子树</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 找到父节点</span></span><br><span class="line">                <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek().val == inorder[in_index])&#123;</span><br><span class="line">                    <span class="comment">// 倒出父节点（已经建好了左子树）</span></span><br><span class="line">                    node = stack.pop();</span><br><span class="line">                    in_index ++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 建立右子树</span></span><br><span class="line">                node.right = <span class="keyword">new</span> TreeNode(pre_val);</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-daily-practice-20211207</title>
    <url>/2021/12/08/Leetcode-daily-practice-20211207/</url>
    <content><![CDATA[<h5 id="剑指-Offer-16-数值的整数次方"><a href="#剑指-Offer-16-数值的整数次方" class="headerlink" title="剑指 Offer 16. 数值的整数次方"></a><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">剑指 Offer 16. 数值的整数次方</a></h5><p>这题我用了累乘的方式，时间复杂度O(n)。但其实有更快的思路。</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/solution/mian-shi-ti-16-shu-zhi-de-zheng-shu-ci-fang-kuai-s/">快速幂</a></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">long</span> b = n;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            x = <span class="number">1</span>/x;</span><br><span class="line">            b = -b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((b &amp; <span class="number">1</span>) == <span class="number">1</span>) ans *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(log~2~n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p>注意这里的b要为long类型，原因是，int类型的<code>-2147483648</code>的相反数仍为<code>-2147483648</code>，这是int类型溢出导致的。</p>
<h5 id="剑指-Offer-14-I-剪绳子"><a href="#剑指-Offer-14-I-剪绳子" class="headerlink" title="剑指 Offer 14- I. 剪绳子"></a><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">剑指 Offer 14- I. 剪绳子</a></h5><p>这题推导数学公式是最简单的方法，结论是，尽可能的剪出长度为3的段，这样乘积最大。这时可用贪心算法。</p>
<ul>
<li>贪心</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">4</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mod = (<span class="keyword">int</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">4</span>)&#123;</span><br><span class="line">            res = res * <span class="number">3</span> % mod;</span><br><span class="line">            n -= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(res * n % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里最后应该返回<code>return (int)(res * n % mod);</code> ，而<code>return (int)res * n % mod;</code>是不同的结果。</p>
<p>当n比较小时，还可以使用动态规划。</p>
<ul>
<li>动态规划</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>; dp[<span class="number">2</span>] = <span class="number">2</span>; dp[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">4</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> max_value = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=i/<span class="number">2</span>; j++)&#123;</span><br><span class="line">                max_value = Math.max(max_value, dp[j] * dp[i-j]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = max_value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="剑指-Offer-13-机器人的运动范围"><a href="#剑指-Offer-13-机器人的运动范围" class="headerlink" title="剑指 Offer 13. 机器人的运动范围"></a><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">剑指 Offer 13. 机器人的运动范围</a></h5><p>这题我本来认为，所有的运动范围都在左上角，理所当然的想用累加的方式。但实际上，除了左上角的区域还有另外的区域。思路是从每一个连通的位置，思考右方向和下方向的位置是否可以到达。为了避免重复探索，需要m*n的布尔数组来指示是否已经探索过了。最后把符合条件的位置数目加起来。可以有三种实现：</p>
<ul>
<li>广度优先算法(使用队列)</li>
<li>递推</li>
<li>递归</li>
</ul>
<p>时间复杂度均为O(m<em>n)，空间复杂度均为O(m</em>n)</p>
<h5 id="剑指-Offer-12-矩阵中的路径"><a href="#剑指-Offer-12-矩阵中的路径" class="headerlink" title="剑指 Offer 12. 矩阵中的路径"></a><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/">剑指 Offer 12. 矩阵中的路径</a></h5><p>这是矩阵搜索问题，可以使用<code>深度优先搜索DFS + 剪枝</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.length, n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board, words, i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">char</span>[] words, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == board.length || i &lt; <span class="number">0</span> || j == board[<span class="number">0</span>].length || j &lt; <span class="number">0</span> || board[i][j] != words[k]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(k == words.length-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        board[i][j] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> result = dfs(board, words, i+<span class="number">1</span>, j, k+<span class="number">1</span>) || dfs(board, words, i, j+<span class="number">1</span>, k+<span class="number">1</span>) || dfs(board, words, i-<span class="number">1</span>, j, k+<span class="number">1</span>) || dfs(board, words, i, j-<span class="number">1</span>, k+<span class="number">1</span>);</span><br><span class="line">        board[i][j] = words[k];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(3^K^MN)</li>
<li>空间复杂度：O(K)</li>
</ul>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-weekly-contest-269</title>
    <url>/2021/11/29/Leetcode-weekly-contest-269/</url>
    <content><![CDATA[<div class="table-container">
<table>
<thead>
<tr>
<th>Score</th>
<th>Finish Time</th>
<th>Q1(3)</th>
<th>Q2(4)</th>
<th>Q3(5)</th>
<th>Q4(6)</th>
</tr>
</thead>
<tbody>
<tr>
<td>8</td>
<td>Null</td>
<td>5:00</td>
<td>Null</td>
<td>30:00</td>
<td>Null</td>
</tr>
</tbody>
</table>
</div>
<h5 id="5938-简单-找出数组排序后的目标下表"><a href="#5938-简单-找出数组排序后的目标下表" class="headerlink" title="5938(简单) 找出数组排序后的目标下表"></a>5938(简单) 找出数组排序后的目标下表</h5><p>​    <a href="https://leetcode-cn.com/problems/find-target-indices-after-sorting-array/">https://leetcode-cn.com/problems/find-target-indices-after-sorting-array/</a></p>
<h5 id="5939-中等-半径为-k-的子数组平均值"><a href="#5939-中等-半径为-k-的子数组平均值" class="headerlink" title="5939(中等) 半径为 k 的子数组平均值"></a>5939(中等) 半径为 k 的子数组平均值</h5><p>​    <a href="https://leetcode-cn.com/problems/k-radius-subarray-averages/">https://leetcode-cn.com/problems/k-radius-subarray-averages/</a></p>
<p>​    这题我的思路不错，下标自增的时候，k半径范围内的数一增一减。但实际上花了很多时间，主要是写了很多if分支，在确定每个分支的功能时花了很多时间。最后还吃了三次罚时，第一次是因为忘记删除debug信息，第二次未通过但没看错误信息，第三次想不到错误的点故意吃的罚时。未通过的用例k为40000，范围很大，就没有再调试了，最后评论区找到了更好的思路。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getAverages(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">        Arrays.fill(res,-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">2</span>*k)&#123;</span><br><span class="line">                res[i - k] = (<span class="keyword">int</span>)(sum / (<span class="number">2</span> * k + <span class="number">1</span>));</span><br><span class="line">                sum -= nums[i - <span class="number">2</span>*k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2091-中等-从数组中移除最大值和最小值"><a href="#2091-中等-从数组中移除最大值和最小值" class="headerlink" title="2091(中等) 从数组中移除最大值和最小值"></a>2091(中等) 从数组中移除最大值和最小值</h5><p>​    <a href="https://leetcode-cn.com/problems/removing-minimum-and-maximum-from-array/">https://leetcode-cn.com/problems/removing-minimum-and-maximum-from-array/</a></p>
<h5 id="5941-困难-找出知晓秘密的所有专家"><a href="#5941-困难-找出知晓秘密的所有专家" class="headerlink" title="5941(困难) 找出知晓秘密的所有专家"></a>5941(困难) 找出知晓秘密的所有专家</h5><p>​    <a href="https://leetcode-cn.com/problems/find-all-people-with-secret/">https://leetcode-cn.com/problems/find-all-people-with-secret/</a></p>
<p>这题考察图的遍历</p>
<p>Dijkstra算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAllPeople</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] meetings, <span class="keyword">int</span> firstPerson)</span> </span>&#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt;[] graph = <span class="keyword">new</span> ArrayList[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] meeting : meetings) &#123;</span><br><span class="line">            graph[meeting[<span class="number">0</span>]].add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;meeting[<span class="number">1</span>], meeting[<span class="number">2</span>]&#125;);</span><br><span class="line">            graph[meeting[<span class="number">1</span>]].add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;meeting[<span class="number">0</span>], meeting[<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 按时间排序</span></span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; q = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; (o1[<span class="number">1</span>] - o2[<span class="number">1</span>]));</span><br><span class="line">        q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;); q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;firstPerson, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">boolean</span>[] vis = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur = q.poll();</span><br><span class="line">            <span class="keyword">int</span> v = cur[<span class="number">0</span>], t = cur[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            vis[v] = <span class="keyword">true</span>;</span><br><span class="line">            res.add(v);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] next : graph[cur[<span class="number">0</span>]]) &#123;</span><br><span class="line">                <span class="keyword">int</span> p = next[<span class="number">0</span>], time = next[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (vis[p] || time &lt; t) <span class="keyword">continue</span>;</span><br><span class="line">                q.offer(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>排序+查并集</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 并查集数组，记录每个元素的祖先节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] p;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找每个元素的祖先，（路径压缩，并查集模板）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x] != x) p[x] = find(p[x]);</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAllPeople</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] meetings, <span class="keyword">int</span> firstPerson)</span> </span>&#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 祖先数组初始化，将每个元素的祖先标记为自己</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) p[i] = i;</span><br><span class="line">        <span class="comment">// 合并0号专家与firstPerson</span></span><br><span class="line">        p[firstPerson] = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, List&lt;<span class="keyword">int</span>[]&gt;&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 构造以时刻为key，会议列表为value的Map，TreeMap将自动按照key升序排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] m : meetings) &#123;</span><br><span class="line">            <span class="comment">// m[2]为会议时刻，每个时刻对应多场会议</span></span><br><span class="line">            List&lt;<span class="keyword">int</span>[]&gt; list = map.getOrDefault(m[<span class="number">2</span>], <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            list.add(m);</span><br><span class="line">            map.put(m[<span class="number">2</span>], list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于每个时刻，遍历两次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : map.keySet()) &#123;</span><br><span class="line">            <span class="comment">// 第一轮遍历，合并集合</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] l : map.get(x)) &#123;</span><br><span class="line">                <span class="keyword">int</span> a = l[<span class="number">0</span>], b = l[<span class="number">1</span>];                </span><br><span class="line">                <span class="keyword">if</span> (p[find(a)] == <span class="number">0</span> || p[find(b)] == <span class="number">0</span>) &#123; p[find(a)] = <span class="number">0</span>; p[find(b)] = <span class="number">0</span>; &#125;</span><br><span class="line">                p[find(b)] = p[find(a)];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第二轮遍历，分场景讨论</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span>[] l : map.get(x)) &#123;</span><br><span class="line">                <span class="keyword">int</span> a = l[<span class="number">0</span>], b = l[<span class="number">1</span>];</span><br><span class="line">                <span class="comment">// 场景一：两位专家在前面的会议均不知道秘密，后面遍历中其中一位专家知道了秘密，瞬时共享，两人都将知道秘密</span></span><br><span class="line">                <span class="keyword">if</span> (p[find(a)] == <span class="number">0</span> || p[find(b)] == <span class="number">0</span>) &#123; p[find(a)] = <span class="number">0</span>; p[find(b)] = <span class="number">0</span>; &#125;</span><br><span class="line">                <span class="comment">// 场景二：两位专家在该时刻始终都不知道秘密，将合并的集合分离开，防止后面时刻有一个专家知道秘密，将秘密分享给另一个专家</span></span><br><span class="line">                <span class="keyword">else</span> &#123; p[a] = a; p[b] = b; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 祖先为0的元素即为知道秘密的专家</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[find(i)] == <span class="number">0</span>) ans.add(i);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-weekly-contest-270</title>
    <url>/2021/12/05/Leetcode-weekly-contest-270/</url>
    <content><![CDATA[<div class="table-container">
<table>
<thead>
<tr>
<th>Score</th>
<th>Finish Time</th>
<th>Q1(3)</th>
<th>Q2(4)</th>
<th>Q3(5)</th>
<th>Q4(6)</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>Null</td>
<td>Null</td>
<td>0:19:33</td>
<td>30:00</td>
<td>Null</td>
</tr>
</tbody>
</table>
</div>
<p>这周的题目特别不对味儿，可能这就是真实的周赛，也可能我只是周赛新手。</p>
<h5 id="5942-简单-找出-3-位偶数"><a href="#5942-简单-找出-3-位偶数" class="headerlink" title="5942(简单)找出 3 位偶数"></a>5942(简单)<a href="https://leetcode-cn.com/problems/finding-3-digit-even-numbers/">找出 3 位偶数</a></h5><p>这题找出3位偶数有三个规则，而且还要满足<code>全部</code>和<code>互不相同</code>，最后按照<code>递增顺序</code>返回，很容易造成思路的混乱，最简单的方法是排除不满足规则的数，最后去重，排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findEvenNumbers(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = digits.length;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i != j &amp;&amp; j != k &amp;&amp; i != k &amp;&amp; digits[i] != <span class="number">0</span> &amp;&amp; digits[k]%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                        set.add(digits[i]*<span class="number">100</span> + digits[j]*<span class="number">10</span> + digits[k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[set.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> temp : set)&#123;</span><br><span class="line">            result[index++] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JDK7之后，Array.sort()采用Timesrot排序算法，最坏时间复杂度为O(n*logn)，最坏空间复杂度是O(n/2)</p>
<ul>
<li>时间复杂度O(N^3)</li>
<li>空间复杂度（最坏O(n/2)）</li>
</ul>
<h5 id="5943-中等-删除链表的中间节点"><a href="#5943-中等-删除链表的中间节点" class="headerlink" title="5943(中等)删除链表的中间节点"></a>5943(中等)<a href="https://leetcode-cn.com/problems/delete-the-middle-node-of-a-linked-list/">删除链表的中间节点</a></h5><p>这是典型的快慢指针题目。唯一要注意的是，中间节点是⌊n/2⌋（<code>⌊x⌋</code>表示≤x的最大整数），这会导致快指针到最后位置时，慢指针正好是要删除的节点，所以要记录慢指针的前节点，方便删除。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteMiddle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        ListNode pre = slow;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre.next = slow.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度O(n)</li>
<li>空间复杂度O(1)</li>
</ul>
<h5 id="5944-中等-从二叉树一个节点到另一个节点每一步的方向"><a href="#5944-中等-从二叉树一个节点到另一个节点每一步的方向" class="headerlink" title="5944(中等)从二叉树一个节点到另一个节点每一步的方向"></a>5944(中等)<a href="https://leetcode-cn.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/">从二叉树一个节点到另一个节点每一步的方向</a></h5><p>首先是寻找两个节点的最小公共祖先，参考<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree">LC.236(中等)二叉树的最近公共祖先</a>，然后求youngest_root到dest的路径，youngest_root到start的深度，这代表U的数量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;    </span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDirections</span><span class="params">(TreeNode root, <span class="keyword">int</span> startValue, <span class="keyword">int</span> destValue)</span> </span>&#123;</span><br><span class="line">        TreeNode young_root = dfs(root, startValue, destValue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加start到young_root的路径</span></span><br><span class="line">        <span class="keyword">int</span> num = findStart(young_root, startValue);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++)&#123;</span><br><span class="line">            res.append(<span class="string">&#x27;U&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加root到young_root的路径</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        findDest(young_root, destValue, sb);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//寻找最近的公共祖先young_root</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">dfs</span><span class="params">(TreeNode root, <span class="keyword">int</span> startValue, <span class="keyword">int</span> destValue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root.val == startValue || root.val == destValue)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode l = dfs(root.left, startValue, destValue);</span><br><span class="line">        TreeNode r = dfs(root.right, startValue, destValue);</span><br><span class="line">        <span class="keyword">if</span>(l != <span class="keyword">null</span> &amp;&amp; r != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻找start到young_root有几个U</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findStart</span><span class="params">(TreeNode root, <span class="keyword">int</span> srcValue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val == srcValue)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(findStart(root.left, srcValue), findStart(root.right, srcValue)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//寻找young_root到dest的路径</span></span><br><span class="line">    <span class="comment">//sb.deleteCharAt()表示，如果没有找到左子树或右子树没有找到dest，就删除刚刚添加的&#x27;L&#x27;或&#x27;R&#x27;，还原路径。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findDest</span><span class="params">(TreeNode root, <span class="keyword">int</span> destValue, StringBuilder sb)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.val == destValue)&#123;</span><br><span class="line">            res.append(sb.toString());</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            sb.append(<span class="string">&#x27;R&#x27;</span>);</span><br><span class="line">            findDest(root.right, destValue, sb);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            sb.append(<span class="string">&#x27;L&#x27;</span>);</span><br><span class="line">            findDest(root.left, destValue, sb);</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：递归栈至多O(n)</li>
</ul>
<h5 id="5932-困难-合法重新排列数对"><a href="#5932-困难-合法重新排列数对" class="headerlink" title="5932(困难)合法重新排列数对"></a>5932(困难)<a href="https://leetcode-cn.com/problems/valid-arrangement-of-pairs/">合法重新排列数对</a></h5><p>找到一个<code>出度（从该点出发的边的数量）</code>比 <code>入度（进入该点的边的数量）</code>大1的点作为起点。如果没找到这样的一个点，那么任何一个点都可以作为起点，这时所有点的<code>入度 = 出度</code>。做法是，从起点出发，遍历任意边，然后把边删除。如果当前点没有任何边连出，才在结果中加入该点（排除环）。递归进行这个过程，得到 “一笔画” 路径的 逆序。最后把路径翻转即可得到最终结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//存放最后遍历的顺序</span></span><br><span class="line">    LinkedList&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//存放所有元素的入度元素</span></span><br><span class="line">    Map&lt;Integer, LinkedList&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//存放所有元素的入度</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; inDegree = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] validArrangement(<span class="keyword">int</span>[][] pairs) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] pair : pairs)&#123;</span><br><span class="line">            <span class="keyword">int</span> out = pair[<span class="number">0</span>], in = pair[<span class="number">1</span>];</span><br><span class="line">            inDegree.put(in, inDegree.getOrDefault(in, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            LinkedList&lt;Integer&gt; list = map.getOrDefault(out, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">            list.add(in);</span><br><span class="line">            map.put(out, list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = pairs[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, LinkedList&lt;Integer&gt;&gt; entry : map.entrySet())&#123;</span><br><span class="line">            <span class="keyword">int</span> key = entry.getKey();</span><br><span class="line">            LinkedList&lt;Integer&gt; outList = entry.getValue();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> inValue = inDegree.getOrDefault(key, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(inValue + <span class="number">1</span> == outList.size())&#123;</span><br><span class="line">                start = key;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(start);</span><br><span class="line">        <span class="keyword">int</span> n = pairs.length;</span><br><span class="line">        <span class="keyword">int</span>[][] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            ans[i][<span class="number">0</span>] = result.pollLast();</span><br><span class="line">            ans[i][<span class="number">1</span>] = result.peekLast();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; list = map.get(start);</span><br><span class="line">        <span class="keyword">while</span>(list != <span class="keyword">null</span> &amp;&amp; !list.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> next = list.pollLast();</span><br><span class="line">            dfs(next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result.add(start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>时间复杂度：O(pairs.length)</p>
</li>
<li><p>空间复杂度：O(pairs.length)</p>
<p>注意题目中排除了自循环和重复循环的用例，否则这个算法不可行。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>PTE-Score</title>
    <url>/2021/11/27/PTE-Score/</url>
    <content><![CDATA[<p>2021.09.18</p>
<img src="/2021/11/27/PTE-Score/pte-score.png" class title="This is the newest pte score">
]]></content>
      <categories>
        <category>certification</category>
      </categories>
      <tags>
        <tag>certification</tag>
        <tag>pte</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云部署SpringBoot应用</title>
    <url>/2021/11/29/%E9%98%BF%E9%87%8C%E4%BA%91%E9%83%A8%E7%BD%B2SpringBoot%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>我买了阿里云的轻量服务器，双十一的折扣不要太划算，43块钱租赁一整年。服务器系统设置成CentOS8，用来验证Spring Boot应用的部署环节。</p>
<p>部署的流程很简单：本地成功运行SpringBoot应用 -&gt; 打成jar包 -&gt; 配置CentOS环境 -&gt; 部署jar包到服务器，可实际上，过程中走了很多弯路，却也有趣。从下午6点一直到1点半，我十分投入，甚至晚饭也忘了。本来打算立即写下这件事的，迫于太晚了，只好推到了早上。</p>
<p>  本地运行SpringBoot</p>
<p>这个应用克隆自<code>https://github.com/gabrieldim/Email-Sender-Spring-Boot.git</code>，实现了通过url发送邮件。需要配置发送人的邮箱信息，这里我用了QQ邮箱做测试。</p>
<p>注意要开启邮箱的第三方服务</p>
<img src="/2021/11/29/%E9%98%BF%E9%87%8C%E4%BA%91%E9%83%A8%E7%BD%B2SpringBoot%E5%BA%94%E7%94%A8/qq_mail_third_party_service_enable.png" class title="开启QQ邮箱第三方服务">
<p>  打成jar包</p>
<p>这里我使用了IDEA的打包工具，但是IDEA给我留了陷阱。</p>
<img src="/2021/11/29/%E9%98%BF%E9%87%8C%E4%BA%91%E9%83%A8%E7%BD%B2SpringBoot%E5%BA%94%E7%94%A8/idea-build_detail_info.png" class title="IDEA打jar包细节信息">
<p>这里的MANIFEST.MF文件应该放在根目录下，也即删除<code>\src\main\java</code>，然后顺着流程走下来，jar包放在<code>.out\artifacts\email_sender-jar</code></p>
<p>  配置CentOS</p>
<p>主要有两部分，安装jdk11和Tomcat。</p>
<p>安装jdk11走了很多弯路，最开始我用wget安装，但是在Oracle官网下载的tar.gz文件总是HTML类型的，导致解压出错。即使在wget命令中添加同意协议的cookie信息，依然如此。最后我换了思路，我先下载到windows本地，然后上传到LINUX服务器。</p>
<p>上传的操作利用了PPUTY工具。其实有很多方法的，但是之前连接AWS虚机的时候安装了PUTTY，所以直接拿来用最方便啦。PPUTY的命令是<code>pscp 本机压缩文件 Linux用户@Linux公用IP:Linux服务器目录</code>。</p>
<p>JDK安装包上传到服务器，首先用<code>tar -zxvf jdk-11.0.13-linux-x64.tar.gz</code>解压到<code>/usr/local/java</code>，这是我放置安装包的地方。然后在<code>vim /etc/profile</code>配置环境变量，在文件末尾添加``</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">## JAVA</span><br><span class="line">JAVA_HOME=/usr/local/jdk-<span class="number">11.0</span>.<span class="number">13</span></span><br><span class="line">JRE_HOME=/usr/local/jdk-<span class="number">11.0</span>.<span class="number">13</span></span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</span><br><span class="line">CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib</span><br><span class="line">export JAVA_HOME JRE_HOME PATH CLASSPATH</span><br></pre></td></tr></table></figure>
<p>最后要<code>source /etc/profile</code>刷新当前shell环境。<code>java -version</code>看到Java信息就算成功。</p>
<p>安装Tomcat最艰难，下载和安装过程和jdk大同小异，只是安装目录是<code>/usr/local/tomcat/apache-tomcat-10.0.13</code>，执行bin目录下启动命令<code>./startup.sh</code>，但是tomcat的启动日志<code>tail -f ../logs/catalina.out</code>一直报错，无法找到<code>./jdk-11.0.13/bin/jre/bin/java</code>无法找到路径，cd到相应目录发现没有jre目录，原来是Oracle搞得鬼，JDK11及以后，不单独提供JRE模块，但是用户可以自行创建JRE，命令则是在jdk的bin目录下执行<code>jlink.exe --module-path jmods --add-modules java.desktop --output jre</code>。之后重启Tomcat还是有错误，把JRE配置为和JDK同一目录便解决啦。</p>
<p>这时Tomcat已经安装好啦。我用windows的浏览器试着连接服务器的8080端口，但一直超时。这部分查了很久，直到看到有篇文章无心插柳提到了防火墙，我想起我忘了开放服务器的8080端口了Orz。</p>
<p>  部署应用</p>
<p>第一次没有成功，解决了上文IDEA留的陷阱就可以啦。</p>
<p>jar包目录下执行<code>java -jar email-sender.jar</code>可以看到Spring的信息。成功！</p>
]]></content>
      <tags>
        <tag>aliyun</tag>
        <tag>springboot</tag>
        <tag>linux</tag>
        <tag>deploy</tag>
      </tags>
  </entry>
</search>
